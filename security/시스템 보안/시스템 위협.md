버퍼 오버플로우 공격
---

버퍼 또는 데이터 저장 공간보다 더 많은 입력이 위치하면 다른 위치의 정보를 변경할 수 있음을 이용한 공격

### 스택 버퍼 오버플로우

스택에 정해진 버퍼보다 큰 공격 코드를 삽입해 반환주소를 변경함

- 공격 대상
  - SetUID가 설정된 루트 권한의 프로그램
- 공격 절차
  - 공격 쉘 코드를 버퍼에 저장
  - 특정 함수의 스택 반환주소를 공격 쉘 코드가 위치한 버퍼 주소로 변경
  - 해당 함수가 호출되면 쉘 코드가 실행되고 루트 권한을 획득할 수 있음

### 힙 버퍼 오버플로우

힙에 할당된 공간이 함수에 대한 포인터를 포함하고 있는 경우, 공격자가 이 주소를 변경하여 겹쳐 쓴 버퍼에 있는 셸 코드를 가리키도록 할 수 있다.

### 대응 방법

#### 컴파일 시간 방어

컴파일할 때 검사하여 오버 플로우를 방지하거나 발견하는 방어 방법

- 고급 수준의 프로그래밍 언어 사용
  - Java, ADA, Python 같은 버퍼 오버플로우가 발생하지 않는 언어
- 안전한 함수 사용
  - 입력 값을 검사하는 함수를 사용
- 안전한 라이브러리의 사용
- 스택 보호 메커니즘(Stack Guard)
  - 함수의 진입과 종료 코드를 조사하여 함수의 스택 프레임에 대해 손상이 있는지 검사
  - 프로그램 호출 시 복귀 주소(RET) 앞에 `canary`값 주입 후 종료 시 변경되었는지 확인
- 스택 쉴드(Stack Shield)
  - 함수 시작 시 복귀 주소(RET)를 `Global RET`라는 특수 스택에 저장
  - 함수 종료 시 저장된 값과 스택의 RET 값을 비교해 탐지

#### 실행 시간 방어

재컴파일 없이 기존 프로그램에 대해 방어할 수 있는 방법

- 주소 공간의 임의 추출(ASLR, Address Space Layout Randomization)
  - 스택을 임의적으로 배치하여 공격자가 실행 코드의 주소를 예측할 수 없게 함
- 실행가능 주소 공간의 보호(Non-Executable Stack)
  - 스택과 힙 영역을 실행 불능으로 만드는 방법
  - `/etc/system`파일 설정
    - `set noexec_user_stack=1`
    - `set noexec_user_stack_log=1`

포맷 스트링 공격
---

포맷 스트링을 인자로 하는 함수의 취약점을 이용한 공격

### 위협 요소

- 프로그램의 파괴
  - 프로세스를 죽게 만들어 다른 공격을 수월하게 만듬
- 프로세스 메모리 보기
  - 시스템 내의 유용한 정보를 수집
- 임의의 메모리 덮어쓰기
  - 어떤 프로세스의 명령 통제권을 장악할 수 있다.

### 대응 방법

- 데이터 형식에 대한 명확한 정의
- 취약점 점검 도구 사용
  - gdb, ltrace, objdump

레이스 컨디션 공격
---

둘 이상의 프로세스나 스레드가 공유자원에 동시에 접근할 때 접근하는 순서에 따라 비정상적인 결과가 발생하는 조건/상황

> 실행되는 프로세스가 임시파일을 만드는 경우, 악의적인 프로그램을 통해 그 프로세스의 실행 중에 끼어들어 임시파일을 목적파일로 연결(심볼릭 링크)하여 악의적인 행위를 할 수 있다.

- 레이스 컨디션 공격의 대상
  - 소유자가 root, SetUID 비트 설정, 임시파일을 생성하는 파일
- 생성되는 임시 파일의 이름을 알고 있어야 함
  - lsof 명령어로 확인

### 대응 방법

- 임시파일에 접근하기 전에 임시파일에 대한 심볼릭 링크 설정 여부와 권한에 대한 검사 과정 추가 
- 가능하면 임시파일을 생성하지 않는다.
- `umask`를 최소 `022` 정도로 유지(755퍼미션)

백도어
---

OS나 프로그램 등에 접근할 때 정상적인 인증 과정을 거치지 않도록 하는 통로

- 서비스 기술자나 유지보수 프로그래머의 접근 편의를 위해서 시스템 설계자가 고의적으로 만듬
- 백 오리피스(back orifice) = 악의적인 백도어
  - 사용자 몰래 사용자 정보를 저장, 유출하기 위한 백도어 프로그램

### 대응 방법

- 프로세스 목록 확인
- `H-IDS` 사용하여 탐지

시스템 자원 고갈 공격
---

시스템이 보유하고 있는 자원을 모두 선점하거나 모두 고갈하는 방식으로 수행된다.

> 서비스 거부 공격(DOS)라고도 부름

### 가용 디스크 자원 고갈 공격

```C
#include<unistd.h>
#include<sys/file.h>

void main(){
  int fd;
  char buf[1000];

  fd = creat("/root/termifile" ,0777);

  while(1){
    write(fd,buf,sizeof(buf); // tempfile 계속 써서 → 디스크 용량 고갈
  }
}
```

### 가용 메모리 자원 고갈 공격

```C
#include<stdio.h>

void main(){
  char *m; // 포인터 변수

  while(1){
    m = malloc(1000); // 동적 할당 → 힙 메모리 고갈
  }
}
```

### 가용 프로세스 자원 고갈 공격

```C
#include<unistd.h>

void main(){
  while(1){
    fork(); // 프로세스 반복 복제 → 가용 프로세스 고갈
    return 0;
  }
}
```

### 프로세스 죽이기 공격

root 권한을 획득한 상태에서 스크립트를 통해 프로세스를 죽이는 기법

```C
#!/bin/sh
sync
kill -15 1
```

리버스 엔지니어링 공격
---

리버스 엔지니어링 과정에서 발견한 취약점으로 공격 코드를 생성

> 리버스 엔지니어링(역공학): 장치나 시스템의 구조를 분석하여 원리를 발견하는 과정

### 대응 방법

- 소스코드 난독화
- 바이너리 난독화 

그 외
---

### 루트킷(Rootkit)

공격자가 언제든지 시스템 root 권한으로 접근할 수 있도록 비밀통로를 지속적으로 유지시켜주는 프로그램

- 시스템 변형을 통해서 자신을 숨기므로 탐지하기 어려움

### GNU Bash 취약점(ShellShock)

취약한 버전의 bash는 환경변수의 함수 선언문 뒤에 임의의 명령어를 삽입할 경우, 환경변수에 설정된 함수 선언의 끝을 인지하지 못하고 삽입한 명령어까지 실행하는 취약점

### 논리폭탄(logic bomb)

특정한 사건이 발생할 때 프로그램이나 일련의 코드를 실행하는 것
