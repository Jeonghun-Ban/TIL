---
tags:
  - cs
  - design-pattern
---

디자인 패턴이란?
---

`객체지향프로그래밍(OOP)`을 하는 데 있어서 `재사용성`을 높이는 것은 중요하지만 어려운 과제이다. 이를 위해서는 적절한 객체와 클래스, 인터페이스를 정의하고 관계를 설정해야만 하는데, 여기서 디자인 패턴의 필요성이 드러난다. 

전문가들은 다양한 문제들을 접하며 찾은 해결책들이 집약된 것이 바로 현재 객체지향설계에 사용되는 `디자인 패턴`이다. 따라서 이러한 패턴을 익히는 것은 이미 여러 차례에 걸쳐 검증된 방식을 효율적으로 사용하기 위해 꼭 필요한 과정이다.

디자인 패턴 요소
---

일반적으로 하나의 패턴에는 아래와 같은 요소를 포함한다.

- `패턴 이름`: 디자인패턴을 설명하는 단어
- `문제`: 해결할 문제와 그 배경을 설명
- `해법`: 설계 구성요소 간의 관계, 책임, 협력 관계
- `결과`: 디자인 패턴을 적용해서 얻는 결과와 장단점

디자인 패턴 카탈로그
---

`GoF의 디자인 패턴`에서는 총 23가지 종류의 패턴이 있다고 소개한다. 여기서는 간단히 이러한 종류가 있구나 하고 넘어가도록 하고, 이후 TIL에서 자세히 정리하도록 하겠다.

### 분류 기준 == '목적'

GoF가 말하는 디자인 패턴을 나누는 두 가지 기준 중 첫번째는 `목적`이다.

#### 생성 패턴

인스턴스를 만드는 과정을 추상화

- [[추상 팩토리]]: 구체적인 클래스를 지정하지 않고 객체들의 집합을 생성하는 인터페이스를 제공.
- [[빌더]]: 복합 객체의 생성 과정과 표현 방법을 분리하여 동일한 생성 절차에서 다른 결과를 만들 수 있게 함.
- `팩토리 메서드`: 객체를 생성하는 인터페이스는 미리 정의하되 인스턴스를 만들 클래스는 서브클래스에서 결정.
- `원형`: 생성할 객체의 종류를 명세하는 데 원형을 정의하고, 이를 복사함으로써 새로운 객체를 생성.
- `단일체`: 클래스의 인스턴스가 하나임을 보장하고, 이 객체에 접근할 수 있는 전역적인 접촉점을 제공.

#### 구조 패턴

클래스나 객체의 합성

- `적응자`: 클래스의 인터페이스를 사용자가 기대하는 것으로 변환하여 호환성을 해결.
- `가교`: 구현부에서 추상층을 분리하여 각자 독립적으로 변형할 수 있게 함.
- `복합체`: 객체들의 관계를 트리 구조로 구성하여 부분-전체 계층을 표현.
- `장식자`: 주어진 상황 및 용도에 따라 어떤 객체에 책임을 덧붙이는 패턴.
- `퍼사드`: 서브시스템에 있는 인터페이스 집합에 대해서 하나의 통합된 인터페이스를 제공.
- `플라이급`: 크기가 작은 객체가 여럿 있을 때, 공유를 통해 이들을 효율적으로 지원.
- `프록시`: 객체로 접근하는 것을 통제하기 위해서 대리자 또는 자리채움자를 제공.

#### 행동 패턴

클래스나 객체의 상호작용

- `책임 연쇄`: 요청을 처리할 수 있는 기회를 하나 이상의 객체에게 부여하여 요청을 주고받는 객체 사이의 결합을 피함.
- `명령`: 요청을 객체의 형태로 캡슐화하여 서로 요청이 다른 사용자의 매개변수화, 요청 저장, 로깅, 연산 취소 지원.
- `해석자`: 주어진 언어에 대해, 그 언어의 문법을 위한 표현 수단을 정의. 해당 문서를 해석하는 해석기 정의.
- `반복자`: 내부 표현부를 노출하지 않고 어떤 객체 집합에 속한 원소들을 순차 접근.
- `중재자`: 한 집합에 속해있는 객체들의 상호작용을 캡슐화하는 객체 정의.
- `메멘토`: 캡슐화를 위배하지 않은 채로 어떤 객체의 내부 상태를 잡아내고 실체화시켜, 이후에 해당 객체가 그 상태로 되돌아올 수 있도록 함.
- `감시자`: 객체들 사이에 일대다 의존 관계를 정의하여, 어떤 객체의 상태가 변할 때 그 객체에 의존성을 가진 다른 객체들이 그 변화를 통지받고 자동으로 갱신할 수 있게 함.
- `상태`: 객체 내부 상태에 따라 스스로 행동을 변경할 수 있게끔 허가.
- `전략`: 동일 계열 알고리즘군을 정의하고 각각의 알고리즘을 캡슐화하여 이들을 상호 교환이 가능하도록 만드는 패턴.
- `템플릿 메서드`: 객체의 연산에는 알고리즘의 뼈대만을 정의하고 각 단계에서 수행할 구체적 처리를 서브클래스 쪽으로 미룸.
- `방문자`: 객체 구조를 이루는 원소에 대해 수행할 연산을 표현하는 패턴.

### 분류 기준 == '범위'

두 번째 분류 기준인 `범위`는 패턴을 `클래스`에 적용하는지 아니면 `객체`에 적용하는지를 구분하는 것이다.

|구분|생성|구조|행동|
|:--:|:--:|:--:|:--:|
|클래스|팩토리 메서드|적응자(class)|해석자<br>템플릿 메서드|
|객체|추상 팩토리<br>빌더<br>원형<br>단일체|적응자(object)<br>가교<br>복합체<br>장식자<br>퍼사드<br>플라이급<br>프록시|책임 연쇄<br>명령<br>해석자<br>중재자<br>메멘토<br>감시자<br>상태<br>전략<br>방문자|

- 클래스 패턴
  - 클래스와 서브클래스 간의 `관련성`을 다루는 패턴
  - 관련성은 주로 `상속`을 말함
  - 컴파일 타임에 `정적`
- 객체 패턴
  - 객체 관련성을 다룸
  - 런타임에 `동적`
  
디자인 패턴 관계도
---

![관계도](https://www.cs.unc.edu/~stotts/GOF/hires/Pictures/bigmap.gif)

위 관계도는 디자인 패턴 간에 존재하는 참조 관계를 나타낸 것이다. 각 패턴을 따로 익히는 것도 중요하지만 각각의 패턴이 어떤 관계를 맺고 있는 지 확인하면서 공부하는 것이 도움이 될 것이다.

참조문헌
---

- Gof의 디자인 패턴 번역본
- [https://www.cs.unc.edu/~stotts/GOF/hires/contfso.htm](https://www.cs.unc.edu/~stotts/GOF/hires/contfso.htm)